

Fitting to the TRANSVIR data prototype

# This is cleaning the TRANSVIR data



```{r}

#install.packages("devtools")
#library(devtools)
devtools::load_all()
library(rjmc)
library(data.table)
library(lubridate)


gambia_pvnt_w2 <- get_data_titre_model_wave2() # This is the empirical prior for the exposure time
gambia_exp_w2 <- get_exposures_wave2() # This is the empirical prior for the exposure time
exp_prior_w2 <- get_exp_prior_wave2() # This is the empirical prior for the exposure time

gambia_exp_w2$inf_pd_time
gambia_exp_w2$vax_time

# Define parameters, priors and support for ab kinetics model (a, b, c), observational model (sigma) and 
# the correlate of protection curve (beta0, beta1)
# Format is [param_name, lower_bound, upper_bound, prior_function (in R), parameter_1 in prior function, parameter_2 in prior function (if needed)]
# add_par_df adds to the par_tab
par_tab <- bind_rows( 
    add_par_df("a", 0.1, 1.5, "norm",  1, 0.5), # ab kinetics    
    add_par_df("b", 0, 1, "norm",  0.3, 0.05), # ab kinetics         
    add_par_df("c_slope", 0.3, 4, "unif", 0.3,  4), # ab kinetics       
    add_par_df("sigma_obs", 0.01, 1, "unif", 0.01, 1), # observational model
    add_par_df("beta0", -10, 10, "unif", -10, 10), # cop model (not used here)
    add_par_df("beta1", -10, 10, "unif", -10, 10) # cop model (not used here)
)



# Likelihood on the observational model, can be defined as anything [or put in c++]
evaluateLogLikelihood <- function(params, jump, jump_inf, covariance, datalist) {
    # datalist is data into the model which is useful
    start_time <- Sys.time()
    N = datalist$N
    knownInfsVec =  datalist$knownInfsVec        
    knownInfsN = datalist$knownInfsN
    knownInfsDate = datalist$knownInfsDate
    endTitreTime = datalist$endTitreTime

    inf_pd_time <- datalist$inf_pd_time
    vax_time <- datalist$vax_time

    N_data = datalist$N_data
    initialTitreValue = datalist$initialTitreValue
    initialTitreTime = datalist$initialTitreTime
    titre_full = datalist$titre_full
    times_full = datalist$times_full
    id_full = datalist$id_full

    # jump is a vector representing vector E^\tau, the timing of exposure, if equal to -1 means not exposued
    # jump_inf is a binary vector representing non-infection (0) or infection (1) at time of exposure. 
    # jump_inf value is irrelevant if E^\tau is -1

    # Get values from the params vector
    a <- params[1]
    b <- params[2]
    c <- params[3]
    sigma_obs <- params[4]

    end_time <- Sys.time()
    execution_time <- end_time - start_time
   # cat("time to get all data: ", execution_time, "\n")

    # Function to determine the antibody kinectics, A_jt
    ll <- 0
    for (i in 1:N_data) {
        titre_val <- titre_full[i]
        time <- times_full[i]
        i_idx <- id_full[i]

      #  start_time <- Sys.time()
        exposure <- c()
        time_exp <- c()

        # determine order and valeus of exposures 
        if (inf_pd_time[i_idx] > -1 && inf_pd_time[i_idx] < time) {
            exposure <- c(exposure, "pre-delta")
            time_exp <- c(time_exp, inf_pd_time[i_idx])
        }
        if (vax_time[i_idx] > -1 && vax_time[i_idx] < time) {
            exposure <- c(exposure, "vax")
            time_exp <- c(time_exp, vax_time[i_idx])
        }
        if (jump_inf[i_idx] == 1 && jump_inf[i_idx] < time) {
            exposure <- c(exposure, "delta")
            time_exp <- c(time_exp, jump_inf[i_idx])
        }
        exposure <- c(exposure, "bleed")
        time_exp <- c(time_exp, time)
      #  end_time <- Sys.time()
      #  execution_time <- end_time - start_time
       # cat("time to get the vectors: ", execution_time, "\n")
        ##### NEED TO ADD IN TIMING OF TITRE
        # Find the estimated titre value, A_jt at the time of the titre bleed

       # start_time <- Sys.time()
        df_order_exp <- data.table(exposure = exposure, time_exp = time_exp)[order(time_exp)][, time_diff := shift(time_exp, type = "lead") - time_exp]
        end_time <- Sys.time()
       # execution_time <- end_time - start_time
       # cat("time to arrange the dataframe: ", execution_time, "\n")
     #   cat(i_idx, " ", i, ":P:", nrow(df_order_exp), "\n")
        titre_est <- initialTitreValue[i_idx]

        for (j in seq_len(nrow(df_order_exp) - 1)) {
            time_until <- df_order_exp[[j, 3]]
            if (df_order_exp$exposure[j] == "pre-delta") {
                if (time_until < 14) {
                    titre_est <- titre_est + (log(exp(a) +  exp(c)) * (time_until) / 14);
                } else {
                    titre_est <- titre_est + (log(exp(a) * exp(-b/10 * (time_until - 14)) + exp(c)));
                }
            } else if (df_order_exp$exposure[j] == "vax") {
                if (time_until < 14) {
                    titre_est <- titre_est + (log(exp(a) +  exp(c)) * (time_until) / 14);
                } else {
                    titre_est <- titre_est + (log(exp(a) * exp(-b/10 * (time_until - 14)) + exp(c)));
                }
            } else if (df_order_exp$exposure[j] == "delta") {
                if (time_until < 14) {
                    titre_est <- titre_est + (log(exp(a) +  exp(c)) * (time_until) / 14);
                } else {
                    titre_est <- titre_est + (log(exp(a) * exp(-b/10 * (time_until - 14)) + exp(c)));
                }            
            }
        }
          #  end_time <- Sys.time()
          #  execution_time <- end_time - start_time
           # cat("time to do the likelihood: ", execution_time, "\n")
        
        ## Observation model for individual i
        ## titre_val is Y_jt, titre_est is A_ji
        if (titre_val == 0) {
            ll <- ll + dnorm(titre_val, titre_est, 0.01, log = TRUE)
        } else {
            ll <- ll + dnorm(titre_val, titre_est, sigma_obs, log = TRUE)
        }
    }
    ll
}

# Your code snippet
start_time <- Sys.time()

# Code snippet you want to measure
# Example:
result <- 5

end_time <- Sys.time()

# Calculate the time difference
execution_time <- end_time - start_time
execution_time


# Logistic correlate of protection model, this is added to the likelihood for each exposed person. Can be defined as anything
cop_func <- function(jump, jumpinf, params, initialTitreValue) {
    ll <- 0
    # COP parameters
    beta0 <- params[5]
    beta1 <- params[6]
 
    p <- 1.0 / (1.0 + exp(- (beta0 + beta1 * initialTitreValue) ) )
    ll <- jumpinf * log(p) + (1 - jumpinf) * log(1 - p)

    ll
}

# Run reversible jump mcmc
runsaveRJMCMC <- function(filename, modelname, evaluateLogLikelihood, data_t_raw, par_tab, exp_prior, cop_func) {
    
    # Clean the data into a format for the sampler
    # data_titre_model format is [id, time, titre]
    # Generate the data_t format
    gambia_exp_w2_d <- gambia_exp_w2 %>% filter(inf_d_time > -1) 
    data_t <- generate_data_t(gambia_pvnt_w2, dplyr::select(gambia_exp_w2_d, pid, id, inf_time = inf_d_time) )
    data_t$inf_pd_time <- gambia_exp_w2$inf_pd_time
    data_t$vax_time <- gambia_exp_w2$vax_time


    # This function creates the list of functions needed for the rjmc_full_func
    model_define <- createModelRJCMCFull(evaluateLogLikelihood, par_tab, cop_func)
    model_define <- addExposurePrior(model_define, data_t, exp_prior, type = "empirical")

    # Settings used for the rjmcmc model, still playing around with optimal settings
    settings <-  list(
        numberChainRuns = 4,
        numberCores = 4,
        iterations = 200000,
        burninPosterior = 100000,
        thin = 100,
        consoleUpdates = 1,
        numberFittedPar = model_define$namesOfParameters %>% length,
        onAdaptiveCov = TRUE,
        updatesAdaptiveCov = 100,
        burninAdaptiveCov = 1000,
        onAdaptiveTemp = TRUE,
        updatesAdaptiveTemp = 10,
        onDebug = FALSE,
        lowerParBounds = model_define$lowerParSupport_fitted,
        upperParBounds = model_define$upperParSupport_fitted,
        covarInitVal = 1e-2, # make very small if struggling to sample to beginning
        covarInitValAdapt = 1e-2, # make very small if struggling to sample to beginning
        covarMaxVal = 1, # decrease if struggling to sample in the middle
        runParallel = TRUE,
        lengthJumpVec = data_t$N,
        noGibbsSteps = 5
    )
    post <- rjmc_full_func(model = model_define, data = data_t, settings = settings)
    fitfull <- list(post = post,  model = model_define, data_t = data_t, par_tab = par_tab, exp_prior = exp_prior)

    dir.create(here::here("outputs", "fits", filename), showWarnings = FALSE)
    dir.create(here::here("outputs", "fits", filename, "figs"), showWarnings = FALSE)

    saveRDS(fitfull, here::here("outputs", "fits", filename, paste0("fit_", modelname, ".RDS")))
}

runsaveRJMCMC( "test/transvir", "wave2", evaluateLogLikelihood, gambia_pvnt_w2, par_tab, exp_prior_w2, cop_func)

```

# Run the post-posterior plotting functions

```{r}

postprocessFigs("test/transvir", "wave1", 4)

```