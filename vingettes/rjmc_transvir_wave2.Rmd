

Fitting to the TRANSVIR data prototype

# This is cleaning the TRANSVIR data



```{r}

#install.packages("devtools")
#library(devtools)
devtools::load_all()
library(rjmc)
library(data.table)
library(lubridate)
library(patchwork)

check_priors <- function(exp_prior_w2, gambia_exp_w2) {
    p1 <- exp_prior_w2 %>% 
        ggplot() + 
            geom_col(aes(x = day, y = prob), color = "red") + 
            theme_bw() + 
            labs(x = "Day of study", y = "Prior exposure probability")
    p2 <- gambia_exp_w2 %>% filter(inf_d_time > -1) %>% 
        ggplot() + 
            geom_histogram(aes(x = inf_d_time)) + 
            theme_bw() + 
            labs(x = "Day of study", y = "Known infection times ")
    p1 / p2 + plot_annotation(tag_levels = "A")
    ggsave(here::here("outputs", "fits", "test", "transvir", "figs", "wave2", "prior_comp.png"))
}

sourceCpp("src/likelihoods/ll_wave2.cpp")

gambia_pvnt_w2 <- get_data_titre_model_wave2() # This is the empirical prior for the exposure time
gambia_exp_w2 <- get_exposures_wave2() # This is the empirical prior for the exposure time
exp_prior_w2 <- get_exp_prior_wave2() # This is the empirical prior for the exposure time
# exp_prior_w2$prob <- 0.001
gambia_exp_w2$inf_pd_time
gambia_exp_w2$vax_time

gambia_pvnt_w2 %>% left_join(gambia_exp_w2) %>% filter(inf_d_time > -1, vax_time == -1, inf_pd_time == -1 ) %>% 
    ggplot() + 
        geom_point(aes(x = time, y = titre)) + 
        geom_line(aes(x = time, y = titre, group = pid), alpha = 0.5) + 
        geom_smooth(aes(x = time, y = titre)) + 
        theme_bw()



# Define parameters, priors and support for ab kinetics model (a, b, c), observational model (sigma) and 
# the correlate of protection curve (beta0, beta1)
# Format is [param_name, lower_bound, upper_bound, prior_function (in R), parameter_1 in prior function, parameter_2 in prior function (if needed)]
# add_par_df adds to the par_tab
par_tab <- bind_rows(
    add_par_df("a_vax", -2, 2, "norm",  0, 1), # ab kinetics
    add_par_df("b_vax", 0, 1, "norm",  0.3, 0.05), # ab kinetics
    add_par_df("c_vax", 0, 4, "unif", 0,  4), # ab kinetics 
    add_par_df("a_pd", -2, 2, "norm",  0, 1), # ab kinetics
    add_par_df("b_pd", 0, 1, "norm",  0.3, 0.05), # ab kinetics
    add_par_df("c_pd", 0, 4, "unif", 0,  4), # ab kinetics
    add_par_df("a_d", -2, 2, "norm",  0, 1), # ab kinetics
    add_par_df("b_d", 0, 1, "norm",  0.3, 0.05), # ab kinetics
    add_par_df("c_d", 0, 4, "unif", 0,  4), # ab kinetics

    add_par_df("tau", 0, 1, "unif", 0, 1), # titre-dep boosting  

    add_par_df("wane", 0.0, 0.1, "unif", 0.0, 0.1), # observational model
    add_par_df("sigma_obs_not", 0.0001, 4, "unif", 0.0001, 4), # observational model

    add_par_df("beta0", -10, 10, "unif", -10, 10), # cop model (not used here)
    add_par_df("beta1", -10, 10, "unif", -10, 10) # cop model (not used here)
)


# Likelihood on the observational model, can be defined as anything [or put in c++]
calculateTitreExp <- function(params, jump, jump_inf, covariance, datalist) {

    titreExp <- calculateTitreExp_cpp(params, jump, jump_inf, covariance, datalist)
    # datalist is data into the model which is useful
    titreExp
}

observationModel <- function(ll, titreval, titre_est, params) {

    if (titre_val <= log10(40)) {
        ll <- ll + log(pcauchy(log10(40), titre_est, params["sigma_obs_not"]))
    } else {
        ll <- ll + log(dcauchy(titre_val, titre_est, params["sigma_obs_not"]))
    }
    ll
}

# Likelihood on the observational model, can be defined as anything [or put in c++]
evaluateLogLikelihood <- function(params, jump, jump_inf, titreinf, covariance, datalist) {

    ll <- evaluateLogLikelihood_cpp(params, jump, jump_inf, titreinf, covariance, datalist)
    # datalist is data into the model which is useful
    ll
}

# Logistic correlate of protection model, this is added to the likelihood for each exposed person. Can be defined as anything
cop_func <- function(jump, jumpinf, params, initialTitreValue) {
    ll <- 0
    # COP parameters
    beta0 <- params[13]
    beta1 <- params[14]
    p <- 1.0 / (1.0 + exp(- (beta0 + beta1 * initialTitreValue) ) )
    ll <- jumpinf * log(p) + (1 - jumpinf) * log(1 - p)

    ll
}

# Run reversible jump mcmc
runsaveRJMCMC <- function(filename, modelname, evaluateLogLikelihood, data_t_raw, par_tab, exp_prior, cop_func, calculate_titre_exp_func, observationalModel) {
    
    # Clean the data into a format for the sampler
    # data_titre_model format is [id, time, titre]
    # Generate the data_t format
    gambia_exp_w2_d <- gambia_exp_w2 %>% filter(inf_d_time > -1) 
    data_t <- generate_data_t(gambia_pvnt_w2, dplyr::select(gambia_exp_w2_d, pid, id, inf_time = inf_d_time) )
    data_t$inf_pd_time <- gambia_exp_w2$inf_pd_time #rep(-1, 295) #gambia_exp_w2$inf_pd_time
    data_t$vax_time <- gambia_exp_w2$vax_time # rep(-1, 295)#rep(-1, 295)gambia_exp_w2$vax_time

    # This function creates the list of functions needed for the rjmc_full_func
    
    model_define <- createModelRJCMCFull(evaluateLogLikelihood, par_tab, cop_func)
    model_define <- addExposurePrior(model_define, data_t, exp_prior, type = "empirical")
    model_define <- addFunctionTitreExp(model_define, calculate_titre_exp_func)
    model_define$observationalModel <- observationalModel

    # Settings used for the rjmcmc model, still playing around with optimal settings
    settings <-  list(
        numberChainRuns = 4,
        numberCores = 4,
        iterations = 200000,
        burninPosterior = 100000,
        thin = 100,
        consoleUpdates = 100,
        numberFittedPar = model_define$namesOfParameters %>% length,
        onAdaptiveCov = TRUE,
        updatesAdaptiveCov = 100,
        burninAdaptiveCov = 1000,
        onAdaptiveTemp = TRUE,
        updatesAdaptiveTemp = 10,
        onDebug = FALSE,
        lowerParBounds = model_define$lowerParSupport_fitted,
        upperParBounds = model_define$upperParSupport_fitted,
        covarInitVal = 1e-2, # make very small if struggling to sample to beginning
        covarInitValAdapt = 1e-2, # make very small if struggling to sample to beginning
        covarMaxVal = 1, # decrease if struggling to sample in the middle
        runParallel = FALSE,
        lengthJumpVec = data_t$N,
        noGibbsSteps = 1
    )
    post <- rjmc_full_func(model = model_define, data = data_t, settings = settings)
    fitfull <- list(post = post,  model = model_define, data_t = data_t, par_tab = par_tab, exp_prior = exp_prior)

    dir.create(here::here("outputs", "fits", filename), showWarnings = FALSE)
    dir.create(here::here("outputs", "fits", filename, "figs"), showWarnings = FALSE)

    saveRDS(fitfull, here::here("outputs", "fits", filename, paste0("fit_", modelname, ".RDS")))
}

check_priors(exp_prior_w2, gambia_exp_w2)
runsaveRJMCMC( "test/transvir", "wave2", evaluateLogLikelihood, 
    gambia_pvnt_w2, par_tab, exp_prior_w2, cop_func, calculateTitreExp, observationModel)

```

```{r}

postprocessFigs_wave2("test/transvir", "wave2", 4)

```

```{r}
filename <- "test/transvir"
modelname <- "wave2"

fitfull <- readRDS(file = here::here("outputs", "fits", filename, paste0("fit_", modelname, ".RDS")))

outputfull <- readRDS(file = here::here("outputs", "fits", filename, paste0("pp_", modelname, ".RDS")))

fit_states <- outputfull$fit_states
filename <- outputfull$filename
modelname <- outputfull$modelname

fitfull <- readRDS(here::here("outputs", "fits", filename, paste0("fit_", modelname, ".RDS")))
data_t <- fitfull$data_t
N <- data_t$N

df_data_alt <- data.frame(
    id = data_t$id_full,
    time = data_t$times_full,
    titre = data_t$titre_full
)

df_data <- data.frame(
    id = 1:N,
    start_titre = data_t$initialTitreValue,
    known_inf = data_t$knownInfsVec,
    known_date = data_t$knownInfsDate
)

# a) Infection over whole process
fit_states_exp_time <- fit_states %>% select(id, exp_ind) %>% 
    summarise(exp_post = mean(exp_ind), .by = "id")
ids_inf <- fit_states_exp_time %>% filter(exp_post > 0.8) %>% pull(id)

fit_states_exp_prob <- fit_states %>% select(id, exp_ind, exp_time) %>% 
    filter(exp_time > -1) %>% group_by(id) %>%
    summarise(exp_time = mean(exp_time))
# a) Infection over whole process


# Fig A. Compare histograms
fit_states_exp_prob %>% left_join(df_data_alt) %>% filter(id %in% ids_inf, time > 0 ) %>% 
    ggplot() +
    geom_histogram(aes(x = exp_time, y = ..density..)) +
    geom_col(data = exp_time, aes(x = day, y = prob), fill = "red", alpha = 0.5) +
    theme_bw()

# Fig B. Compare titre at start of study to end
fit_states_exp_time %>% left_join(df_data_alt) %>% filter(id %in% ids_inf) %>% left_join(df_data) %>% 
    ggplot() + 
        geom_point(aes(x = time, y = titre, group = id, fill = exp_post), shape = 21, size = 3, alpha = 0.6) +
        geom_line(aes(x = time, y = titre, group = id, color = exp_post), shape = 21, size = 0.5, alpha = 0.9) + 
        theme_bw()

# Fig C. Individual-level plots of exposure times
exposure_plot <- fit_states %>% filter(exp_ind == 1, inf_ind == 1) %>% select(id, exp_time) %>% group_by(id) %>% mean_qi(exp_time) %>% 
    filter(!id %in% ids_inf)

post <- fitfull$post
mcmc_mean <- post$mcmc %>% combine %>% as.data.frame %>% 
    summarise(across(c(a_d, b_d, c_d, sigma_obs), mean)) 

ab_function <- function(a, b, c, T) {
    1:T %>% map( 
        function(t) {
            if (t < 14) {
                titre_init <- 0 +  (log(exp(a) +  exp(c)) * (t) / 14);
            } else {
                titre_init <- 0 + (log(exp(a) * exp(-b/10 * ((t) - 14)) + exp(c)));
            }
        }
    ) %>% unlist
}

exposure_plot_trim <- exposure_plot %>% select(id, exp_time)

traj_exposure <- map_df(1:nrow(exposure_plot_trim),
    ~data.frame(
        id = exposure_plot_trim[[.x, 1]],    
        time = 1:300,
        titre = c(rep(0, round(exposure_plot_trim[[.x, 2]], 0)), ab_function(mcmc_mean[["a_d"]], mcmc_mean[["b_d"]], mcmc_mean[["c_d"]], 300 - round(exposure_plot_trim[[.x, 2]], 0)))
    )
)

exposure_plot %>% 
    ggplot() + 
        geom_rect(aes(xmin = .lower, xmax = .upper, ymin = 0, ymax = 3), fill = "red", alpha = 0.4) + 
        geom_rect(aes(xmin = exp_time - 2, xmax = exp_time + 2, ymin = 0, ymax = 3), fill = "red", alpha = 0.8) + 
        geom_line(data = traj_exposure, aes(x = time, y = titre, group = id), alpha = 1) +
        geom_point(dat = fit_states_exp_prob %>% left_join(df_data_alt) %>% filter(!id %in% ids_inf), 
            aes(x = time, y = titre, group = id), shape = 21, size = 3, alpha = 0.6) +
        theme_bw() + 
        labs(x = "Time of exposure", y = "Number of exposures") + 
        ggtitle("Posterior distribution of exposure times") 



```




# Run the post-posterior plotting functions

```{r}

library(patchwork)
require(posterior)
require(bayesplot)
require(ggdist)

postprocess_run( "test/transvir", "wave2", 4)
outputfull <- readRDS(file = here::here("outputs", "fits", "test/transvir", paste0("pp_", "wave2", ".RDS")))

postprocessFigs_wave2 <- function(filename, modelname, n_chains) {
    postprocess_run( filename, modelname, n_chains)
    outputfull <- readRDS(file = here::here("outputs", "fits", filename, paste0("pp_", modelname, ".RDS")))

    plot_trace(outputfull)
    plot_abkinetics(outputfull)
    plot_inf_rec(outputfull)
    plot_exp_rec(outputfull)
    plot_exp_times_rec(outputfull)
    plot_cop_rec(outputfull)
}



 
plot_trace(outputfull) #
plot_abkinetics(outputfull)
plot_inf_rec(outputfull) #
plot_exp_rec(outputfull)
plot_exp_times_rec(outputfull)
plot_cop_rec(outputfull)















library(patchwork)
# plot_exp_rec
fit_states <- outputfull$fit_states
filename <- outputfull$filename
modelname <- outputfull$modelname

fitfull <- readRDS(here::here("outputs", "fits", filename, paste0("fit_", modelname, ".RDS")))
data_t <- fitfull$data_t
N <- data_t$N

df_data <- data.frame(
    id = 1:N,
    start_titre = data_t$initialTitreValue
)

# a) Infection over whole process
fit_states_exp_prob <- fit_states %>% select(id, exp_ind) %>% summarise(exp_post = mean(exp_ind), .by = "id")

figA <- fit_states_exp_prob %>% left_join(df_data) %>% 
    ggplot() + 
        geom_point(aes(x = start_titre, y = exp_post), shape = 21, size = 3, alpha = 0.6) + 
        theme_bw() + 
        ylim(0, 1) +
        labs(x = "Titre at start of study", y = "Posterior probability of exposure", fill = "Exposure and infection status") + 
        ggtitle("Posterior plots of probability of exposure compared to simulated data") 

no_exp_fit_df <- fit_states %>% select(id, sample, exp_ind) %>% summarise(exp_ind_sum = sum(exp_ind), .by = "sample")

figB <- no_exp_fit_df %>% summarise(n = n()  / 4000, .by = exp_ind_sum) %>%
    ggplot() + 
        geom_col(aes(x = exp_ind_sum, y = n), alpha = 0.8) + 
        theme_bw()  + 
        labs(y = "Posterior density", x = expression("Estimated number of exposures in epidemic, n"[Z])) + 
        ggtitle("Recovery of population-level exposure burden")

figB + plot_annotation(tag_levels = "A") 

# plot_exp_times_rec 


fit_states <- outputfull$fit_states
filename <- outputfull$filename
modelname <- outputfull$modelname

fitfull <- readRDS(here::here("outputs", "fits", filename, paste0("fit_", modelname, ".RDS")))
data_t <- fitfull$data_t
N <- data_t$N

df_data <- data.frame(
    id = 1:N,
    start_titre = data_t$initialTitreValue
)
fit_states_exp_prob <- fit_states %>% select(id, exp_ind) %>% summarise(exp_post = mean(exp_ind), .by = "id")

dataplt <- fit_states %>% filter(exp_ind == 1) %>% select(id, exp_time) %>% group_by(id) %>% mean_qi(exp_time) %>% left_join(fit_states_exp_prob)

pid_order1 <- dataplt %>% arrange(exp_time) %>% pull(id)

figB <- dataplt %>% mutate(id = factor(id, levels = pid_order1)) %>%
    ggplot() + 
        geom_linerange(aes(y = id, xmin = .lower, xmax = .upper, color = exp_post)) + 
        geom_point(aes(y = id, x = exp_time)) + 
        labs(x = "Time in study", y = "ID", fill = "Posterior probability of exposure") + theme_bw() + 
        theme(axis.text.y = element_blank()) + 
        ggtitle("Recovery of timings of exposure over epidemic") 


dataplt_inf <- fit_states %>% filter(inf_ind == 1) %>% select(id, exp_time) %>% group_by(id) %>% mean_qi(exp_time)

figC <- dataplt_inf %>% select(id, exp_time) %>% 
    rename(`Model recovery` = exp_time) %>%
    pivot_longer(!id, names_to = "type", values_to = "time") %>%
    ggplot() + 
        geom_density(aes(x = time, y = ..count.., fill = type), size = 2, alpha = 0.5, shape = 21) + 
        theme_bw()  + 
        labs(x = "Time in study", y = "Number of people infected daily", fill = "") + 
        ggtitle("Recovery of infection timings")


figB / figC + plot_annotation(tag_levels = "A") 

# plot_cop_rec


    fit_states <- outputfull$fit_states
    filename <- outputfull$filename
    modelname <- outputfull$modelname

    fitfull <- readRDS(here::here("outputs", "fits", filename, paste0("fit_", modelname, ".RDS")))
    post <- fitfull$post

    reps <-  post$mcmc %>% combine %>% as.data.frame  %>% pivot_longer(everything(), names_to = "param", values_to = "value") %>%
            mutate(type = "Posterior distribution") %>% filter(param %in% c("beta0", "beta1"))

    b0_rep <- reps %>% filter(param == "beta0") %>% pull(value)
    b1_rep <- reps %>% filter(param == "beta1") %>% pull(value)

    biomarker_protection <- function(biomarker_quantity, biomarker_prot_midpoint, biomarker_prot_width) {
        risk <- 1 - 1/(1 + exp(biomarker_prot_width * (biomarker_quantity - biomarker_prot_midpoint)))
        return(risk)
    }

    lol <- 1:1000 %>% purrr::map_df(
        ~data.frame(
            t = seq(0, 4, 0.1),
            vals = 1.0 / (1.0 + exp(-(b0_rep[.x] + b1_rep[.x] * seq(0, 4, 0.1))))
        )
    )

    lol %>% ggplot() + 
        stat_lineribbon(aes(x = t, y = vals, color = "Recovered COP curve"), fill = "blue", alpha = 0.5, .width = c(0.5, 0.95)) + 
        theme_bw() + 
        ylim(0, 1) +
        labs(x = expression("Titre at start of study Y"[j]^0), y = expression("Posterior probability of infection for correlate of protection, f"[cop]*"(Y"[j]^0*", "*theta[cop]*")"), color = "Curve type")


plot_trace(outputfull)
plot_abkinetics(outputfull)
plot_inf_rec(outputfull)
plot_exp_rec(outputfull)
plot_exp_times_rec(outputfull)
plot_cop_rec(outputfull)

postprocessFigs("test/transvir", "wave1", 4)

```














# Redundant code

```{r}

    N = datalist$N
    knownInfsVec =  datalist$knownInfsVec        
    knownInfsN = datalist$knownInfsN
    knownInfsDate = datalist$knownInfsDate
    endTitreTime = datalist$endTitreTime

    # 
    inf_pd_time <- datalist$inf_pd_time
    vax_time <- datalist$vax_time

    N_data = datalist$N_data
    initialTitreValue = datalist$initialTitreValue
    initialTitreTime = datalist$initialTitreTime
    titre_full = datalist$titre_full
    times_full = datalist$times_full
    id_full = datalist$id_full

    # jump is a vector representing vector E^\tau, the timing of exposure, if equal to -1 means not exposued
    # jump_inf is a binary vector representing non-infection (0) or infection (1) at time of exposure. 
    # jump_inf value is irrelevant if E^\tau is -1

    # Get values from the params vector
    a <- params[1]
    b <- params[2]
    c <- params[3]
    sigma_obs <- params[4]

    end_time <- Sys.time()
    execution_time <- end_time - start_time
   # cat("time to get all data: ", execution_time, "\n")

    # Function to determine the antibody kinectics, A_jt
    ll <- 0
    for (i in 1:N_data) {
        titre_val <- titre_full[i]
        time <- times_full[i]
        i_idx <- id_full[i]

      #  start_time <- Sys.time()
        exposure <- c()
        time_exp <- c()

        # determine order and valeus of exposures 
        if (inf_pd_time[i_idx] > -1 && inf_pd_time[i_idx] < time) {
            exposure <- c(exposure, "pre-delta")
            time_exp <- c(time_exp, inf_pd_time[i_idx])
        }
        if (vax_time[i_idx] > -1 && vax_time[i_idx] < time) {
            exposure <- c(exposure, "vax")
            time_exp <- c(time_exp, vax_time[i_idx])
        }
        if (jump_inf[i_idx] == 1 && jump_inf[i_idx] < time) {
            exposure <- c(exposure, "delta")
            time_exp <- c(time_exp, jump_inf[i_idx])
        }
        exposure <- c(exposure, "bleed")
        time_exp <- c(time_exp, time)
      #  end_time <- Sys.time()
      #  execution_time <- end_time - start_time
       # cat("time to get the vectors: ", execution_time, "\n")
        ##### NEED TO ADD IN TIMING OF TITRE
        # Find the estimated titre value, A_jt at the time of the titre bleed

       # start_time <- Sys.time()
        df_order_exp <- data.table(exposure = exposure, time_exp = time_exp)[order(time_exp)][, time_diff := shift(time_exp, type = "lead") - time_exp]
        end_time <- Sys.time()
       # execution_time <- end_time - start_time
       # cat("time to arrange the dataframe: ", execution_time, "\n")
     #   cat(i_idx, " ", i, ":P:", nrow(df_order_exp), "\n")
        titre_est <- initialTitreValue[i_idx]

        for (j in seq_len(nrow(df_order_exp) - 1)) {
            time_until <- df_order_exp[[j, 3]]
            if (df_order_exp$exposure[j] == "pre-delta") {
                if (time_until < 14) {
                    titre_est <- titre_est + (log(exp(a) +  exp(c)) * (time_until) / 14);
                } else {
                    titre_est <- titre_est + (log(exp(a) * exp(-b/10 * (time_until - 14)) + exp(c)));
                }
            } else if (df_order_exp$exposure[j] == "vax") {
                if (time_until < 14) {
                    titre_est <- titre_est + (log(exp(a) +  exp(c)) * (time_until) / 14);
                } else {
                    titre_est <- titre_est + (log(exp(a) * exp(-b/10 * (time_until - 14)) + exp(c)));
                }
            } else if (df_order_exp$exposure[j] == "delta") {
                if (time_until < 14) {
                    titre_est <- titre_est + (log(exp(a) +  exp(c)) * (time_until) / 14);
                } else {
                    titre_est <- titre_est + (log(exp(a) * exp(-b/10 * (time_until - 14)) + exp(c)));
                }            
            }
        }
          #  end_time <- Sys.time()
          #  execution_time <- end_time - start_time
           # cat("time to do the likelihood: ", execution_time, "\n")
        
        ## Observation model for individual i
        ## titre_val is Y_jt, titre_est is A_ji
        if ( titre_val < log10(20)) {
            ll <- ll + pcauchy(log10(20), titre_est, sigma_obs, log.p = TRUE)
        } else {
            ll <- ll + dcauchy(titre_val, titre_est, sigma_obs, log = TRUE)
        }
    }
    ll

```